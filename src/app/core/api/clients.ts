//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase, HttpContext } from '@angular/common/http';
import { FileParameter } from './file-parameter';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAuthAdminClient {
    /**
     * @return OK
     */
    registerLeader(body: RegisterLeaderCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    registerDoctor(body: RegisterDoctorCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    delete(body: DeleteCommand): Observable<ResultOfboolean>;
    /**
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    getAllDoctor(pageSize?: number | undefined, pageNumber?: number | undefined): Observable<ResultOfIEnumerableOfDoctorDto>;
    /**
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    getAllLeader(pageSize?: number | undefined, pageNumber?: number | undefined): Observable<ResultOfIEnumerableOfLeaderDto>;
    /**
     * @return OK
     */
    activateUser(userId: string): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    deactivateUser(userId: string): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthAdminClient implements IAuthAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    registerLeader(body: RegisterLeaderCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/AuthAdmin/RegisterLeader";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterLeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterLeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processRegisterLeader(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    registerDoctor(body: RegisterDoctorCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/AuthAdmin/RegisterDoctor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterDoctor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterDoctor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processRegisterDoctor(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    delete(body: DeleteCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/AuthAdmin/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    getAllDoctor(pageSize?: number | undefined, pageNumber?: number | undefined, httpContext?: HttpContext): Observable<ResultOfIEnumerableOfDoctorDto> {
        let url_ = this.baseUrl + "/api/admin/AuthAdmin/GetAllDoctor?";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDoctor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDoctor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfIEnumerableOfDoctorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfIEnumerableOfDoctorDto>;
        }));
    }

    protected processGetAllDoctor(response: HttpResponseBase): Observable<ResultOfIEnumerableOfDoctorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfIEnumerableOfDoctorDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    getAllLeader(pageSize?: number | undefined, pageNumber?: number | undefined, httpContext?: HttpContext): Observable<ResultOfIEnumerableOfLeaderDto> {
        let url_ = this.baseUrl + "/api/admin/AuthAdmin/GetAllLeader?";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfIEnumerableOfLeaderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfIEnumerableOfLeaderDto>;
        }));
    }

    protected processGetAllLeader(response: HttpResponseBase): Observable<ResultOfIEnumerableOfLeaderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfIEnumerableOfLeaderDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    activateUser(userId: string, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/AuthAdmin/ActivateUser/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processActivateUser(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deactivateUser(userId: string, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/AuthAdmin/DeactivateUser/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDeactivateUser(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAuthClient {
    /**
     * @return OK
     */
    login(body: LoginCommand): Observable<ResultOfAuthModelDto>;
    /**
     * @return OK
     */
    changePassword(body: ChangePasswordCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    refreshToken(): Observable<ResultOfAuthModelDto>;
    /**
     * @return OK
     */
    revokeToken(body: RevokeTokenCommand): Observable<void>;
    /**
     * @return OK
     */
    logout(): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    login(body: LoginCommand, httpContext?: HttpContext): Observable<ResultOfAuthModelDto> {
        let url_ = this.baseUrl + "/api/Auth/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfAuthModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfAuthModelDto>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ResultOfAuthModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfAuthModelDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    changePassword(body: ChangePasswordCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/Auth/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    refreshToken(httpContext?: HttpContext): Observable<ResultOfAuthModelDto> {
        let url_ = this.baseUrl + "/api/Auth/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfAuthModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfAuthModelDto>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<ResultOfAuthModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfAuthModelDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    revokeToken(body: RevokeTokenCommand, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/RevokeToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevokeToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevokeToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRevokeToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    logout(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICollegeAdminClient {
    /**
     * @return OK
     */
    create(body: AddCollegeCommand): Observable<ResultOfCollegeDto>;
    /**
     * @return OK
     */
    update(body: UpdateCollegeCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    delete(collegeId: number): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class CollegeAdminClient implements ICollegeAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    create(body: AddCollegeCommand, httpContext?: HttpContext): Observable<ResultOfCollegeDto> {
        let url_ = this.baseUrl + "/api/admin/CollegeAdmin/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCollegeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCollegeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfCollegeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfCollegeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    update(body: UpdateCollegeCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/CollegeAdmin/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    delete(collegeId: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/CollegeAdmin/Delete/{collegeId}";
        if (collegeId === undefined || collegeId === null)
            throw new globalThis.Error("The parameter 'collegeId' must be defined.");
        url_ = url_.replace("{collegeId}", encodeURIComponent("" + collegeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICollegePublicClient {
    /**
     * @return OK
     */
    getAllColleges(universityId: number): Observable<ResultOfListOfGetCollegeDto>;
    /**
     * @return OK
     */
    getCollegeById(collegeId: number): Observable<ResultOfCollegeDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CollegePublicClient implements ICollegePublicClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    getAllColleges(universityId: number, httpContext?: HttpContext): Observable<ResultOfListOfGetCollegeDto> {
        let url_ = this.baseUrl + "/api/CollegePublic/GetAllColleges/{universityId}";
        if (universityId === undefined || universityId === null)
            throw new globalThis.Error("The parameter 'universityId' must be defined.");
        url_ = url_.replace("{universityId}", encodeURIComponent("" + universityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllColleges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllColleges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfGetCollegeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfGetCollegeDto>;
        }));
    }

    protected processGetAllColleges(response: HttpResponseBase): Observable<ResultOfListOfGetCollegeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfGetCollegeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCollegeById(collegeId: number, httpContext?: HttpContext): Observable<ResultOfCollegeDto> {
        let url_ = this.baseUrl + "/api/CollegePublic/GetCollegeById/{collegeId}";
        if (collegeId === undefined || collegeId === null)
            throw new globalThis.Error("The parameter 'collegeId' must be defined.");
        url_ = url_.replace("{collegeId}", encodeURIComponent("" + collegeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollegeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollegeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCollegeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCollegeDto>;
        }));
    }

    protected processGetCollegeById(response: HttpResponseBase): Observable<ResultOfCollegeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfCollegeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICurriulumAdminClient {
    /**
     * @return OK
     */
    create(body: AddCurriculumCommand): Observable<ResultOfCurriculumDto>;
    /**
     * @return OK
     */
    update(body: UpdateCurriculumCommand): Observable<ResultOfCurriculumDto>;
    /**
     * @return OK
     */
    delete(id: number): Observable<ResultOfboolean>;
    /**
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    bySubjectId(subjectId: number, pageSize?: number | undefined, pageNumber?: number | undefined): Observable<ResultOfListOfAdminCurriculumDto>;
    /**
     * @return OK
     */
    togglePublish(id: number): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    updateDate(body: UpdateDateCurriculumCommand): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class CurriulumAdminClient implements ICurriulumAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    create(body: AddCurriculumCommand, httpContext?: HttpContext): Observable<ResultOfCurriculumDto> {
        let url_ = this.baseUrl + "/api/admin/CurriulumAdmin/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCurriculumDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCurriculumDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfCurriculumDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfCurriculumDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    update(body: UpdateCurriculumCommand, httpContext?: HttpContext): Observable<ResultOfCurriculumDto> {
        let url_ = this.baseUrl + "/api/admin/CurriulumAdmin/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCurriculumDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCurriculumDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfCurriculumDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfCurriculumDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    delete(id: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/CurriulumAdmin/Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    bySubjectId(subjectId: number, pageSize?: number | undefined, pageNumber?: number | undefined, httpContext?: HttpContext): Observable<ResultOfListOfAdminCurriculumDto> {
        let url_ = this.baseUrl + "/api/admin/CurriulumAdmin/BySubjectId/{subjectId}?";
        if (subjectId === undefined || subjectId === null)
            throw new globalThis.Error("The parameter 'subjectId' must be defined.");
        url_ = url_.replace("{subjectId}", encodeURIComponent("" + subjectId));
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBySubjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBySubjectId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfAdminCurriculumDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfAdminCurriculumDto>;
        }));
    }

    protected processBySubjectId(response: HttpResponseBase): Observable<ResultOfListOfAdminCurriculumDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfAdminCurriculumDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    togglePublish(id: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/CurriulumAdmin/TogglePublish/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTogglePublish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTogglePublish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processTogglePublish(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateDate(body: UpdateDateCurriculumCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/CurriulumAdmin/UpdateDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUpdateDate(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICurriulumPublicClient {
    /**
     * @return OK
     */
    getAllByDeptIdAndYearId(departmentId: number, yearId: number): Observable<ResultOfListOfGetCurriculumDto>;
    /**
     * @return OK
     */
    getById(id: number): Observable<ResultOfGetCurriculumDto>;
    /**
     * @return OK
     */
    byDoctorId(userId: string): Observable<ResultOfListOfGetCurriculumDto>;
    /**
     * @return OK
     */
    byStudentId(userId: string): Observable<ResultOfListOfGetCurriculumDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CurriulumPublicClient implements ICurriulumPublicClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    getAllByDeptIdAndYearId(departmentId: number, yearId: number, httpContext?: HttpContext): Observable<ResultOfListOfGetCurriculumDto> {
        let url_ = this.baseUrl + "/api/CurriulumPublic/GetAllByDeptIdAndYearId/{departmentId}/{yearId}";
        if (departmentId === undefined || departmentId === null)
            throw new globalThis.Error("The parameter 'departmentId' must be defined.");
        url_ = url_.replace("{departmentId}", encodeURIComponent("" + departmentId));
        if (yearId === undefined || yearId === null)
            throw new globalThis.Error("The parameter 'yearId' must be defined.");
        url_ = url_.replace("{yearId}", encodeURIComponent("" + yearId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByDeptIdAndYearId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByDeptIdAndYearId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfGetCurriculumDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfGetCurriculumDto>;
        }));
    }

    protected processGetAllByDeptIdAndYearId(response: HttpResponseBase): Observable<ResultOfListOfGetCurriculumDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfGetCurriculumDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getById(id: number, httpContext?: HttpContext): Observable<ResultOfGetCurriculumDto> {
        let url_ = this.baseUrl + "/api/CurriulumPublic/GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetCurriculumDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetCurriculumDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfGetCurriculumDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfGetCurriculumDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    byDoctorId(userId: string, httpContext?: HttpContext): Observable<ResultOfListOfGetCurriculumDto> {
        let url_ = this.baseUrl + "/api/CurriulumPublic/ByDoctorId/{UserId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{UserId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processByDoctorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processByDoctorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfGetCurriculumDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfGetCurriculumDto>;
        }));
    }

    protected processByDoctorId(response: HttpResponseBase): Observable<ResultOfListOfGetCurriculumDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfGetCurriculumDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    byStudentId(userId: string, httpContext?: HttpContext): Observable<ResultOfListOfGetCurriculumDto> {
        let url_ = this.baseUrl + "/api/CurriulumPublic/ByStudentId/{UserId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{UserId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processByStudentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processByStudentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfGetCurriculumDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfGetCurriculumDto>;
        }));
    }

    protected processByStudentId(response: HttpResponseBase): Observable<ResultOfListOfGetCurriculumDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfGetCurriculumDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IDepartmentAdminClient {
    /**
     * @return OK
     */
    createDepartment(body: AddDepartmentCommand): Observable<ResultOfDepartmentDto>;
    /**
     * @return OK
     */
    updateDepartment(body: UpdateDepartmentCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    deleteDepartment(departmentId: number): Observable<ResultOfboolean>;
    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getAllDepartmentsByCollegeId(collegeId: number, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<ResultOfListOfDepartmentDto>;
    /**
     * @return OK
     */
    togglePublishDepartment(departmentId: number): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class DepartmentAdminClient implements IDepartmentAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    createDepartment(body: AddDepartmentCommand, httpContext?: HttpContext): Observable<ResultOfDepartmentDto> {
        let url_ = this.baseUrl + "/api/admin/DepartmentAdmin/CreateDepartment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfDepartmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfDepartmentDto>;
        }));
    }

    protected processCreateDepartment(response: HttpResponseBase): Observable<ResultOfDepartmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfDepartmentDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateDepartment(body: UpdateDepartmentCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/DepartmentAdmin/UpdateDepartment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUpdateDepartment(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteDepartment(departmentId: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/DepartmentAdmin/DeleteDepartment/{departmentId}";
        if (departmentId === undefined || departmentId === null)
            throw new globalThis.Error("The parameter 'departmentId' must be defined.");
        url_ = url_.replace("{departmentId}", encodeURIComponent("" + departmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDeleteDepartment(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getAllDepartmentsByCollegeId(collegeId: number, pageNumber?: number | undefined, pageSize?: number | undefined, httpContext?: HttpContext): Observable<ResultOfListOfDepartmentDto> {
        let url_ = this.baseUrl + "/api/admin/DepartmentAdmin/GetAllDepartmentsByCollegeId/{collegeId}?";
        if (collegeId === undefined || collegeId === null)
            throw new globalThis.Error("The parameter 'collegeId' must be defined.");
        url_ = url_.replace("{collegeId}", encodeURIComponent("" + collegeId));
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartmentsByCollegeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartmentsByCollegeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfDepartmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfDepartmentDto>;
        }));
    }

    protected processGetAllDepartmentsByCollegeId(response: HttpResponseBase): Observable<ResultOfListOfDepartmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfDepartmentDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    togglePublishDepartment(departmentId: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/DepartmentAdmin/TogglePublishDepartment/{departmentId}";
        if (departmentId === undefined || departmentId === null)
            throw new globalThis.Error("The parameter 'departmentId' must be defined.");
        url_ = url_.replace("{departmentId}", encodeURIComponent("" + departmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTogglePublishDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTogglePublishDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processTogglePublishDepartment(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IDepartmentPublicClient {
    /**
     * @return OK
     */
    getAllDepartments(yearId: number): Observable<ResultOfListOfGetDepartmentDto>;
    /**
     * @return OK
     */
    getDepartmentById(departmentId: number): Observable<ResultOfGetDepartmentDto>;
}

@Injectable({
    providedIn: 'root'
})
export class DepartmentPublicClient implements IDepartmentPublicClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    getAllDepartments(yearId: number, httpContext?: HttpContext): Observable<ResultOfListOfGetDepartmentDto> {
        let url_ = this.baseUrl + "/api/DepartmentPublic/GetAllDepartments/{yearId}";
        if (yearId === undefined || yearId === null)
            throw new globalThis.Error("The parameter 'yearId' must be defined.");
        url_ = url_.replace("{yearId}", encodeURIComponent("" + yearId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfGetDepartmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfGetDepartmentDto>;
        }));
    }

    protected processGetAllDepartments(response: HttpResponseBase): Observable<ResultOfListOfGetDepartmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfGetDepartmentDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getDepartmentById(departmentId: number, httpContext?: HttpContext): Observable<ResultOfGetDepartmentDto> {
        let url_ = this.baseUrl + "/api/DepartmentPublic/GetDepartmentById/{departmentId}";
        if (departmentId === undefined || departmentId === null)
            throw new globalThis.Error("The parameter 'departmentId' must be defined.");
        url_ = url_.replace("{departmentId}", encodeURIComponent("" + departmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetDepartmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetDepartmentDto>;
        }));
    }

    protected processGetDepartmentById(response: HttpResponseBase): Observable<ResultOfGetDepartmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfGetDepartmentDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFilePrivateClient {
    /**
     * @param curriculumId (optional) 
     * @param uploadedById (optional) 
     * @param description (optional) 
     * @param formFile (optional) 
     * @return OK
     */
    uploadFile(curriculumId?: number | undefined, uploadedById?: string | undefined, description?: string | undefined, formFile?: FileParameter | undefined): Observable<ResultOfstring>;
    /**
     * @return OK
     */
    deleteFile(id: number): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    rateFile(body: RatingFileCommand): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class FilePrivateClient implements IFilePrivateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @param curriculumId (optional) 
     * @param uploadedById (optional) 
     * @param description (optional) 
     * @param formFile (optional) 
     * @return OK
     */
    uploadFile(curriculumId?: number | undefined, uploadedById?: string | undefined, description?: string | undefined, formFile?: FileParameter | undefined, httpContext?: HttpContext): Observable<ResultOfstring> {
        let url_ = this.baseUrl + "/api/private/FilePrivate/UploadFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (curriculumId === null || curriculumId === undefined)
            throw new globalThis.Error("The parameter 'curriculumId' cannot be null.");
        else
            content_.append("curriculumId", curriculumId.toString());
        if (uploadedById === null || uploadedById === undefined)
            throw new globalThis.Error("The parameter 'uploadedById' cannot be null.");
        else
            content_.append("uploadedById", uploadedById.toString());
        if (description === null || description === undefined)
            throw new globalThis.Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (formFile === null || formFile === undefined)
            throw new globalThis.Error("The parameter 'formFile' cannot be null.");
        else
            content_.append("FormFile", formFile.data, formFile.fileName ? formFile.fileName : "FormFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfstring>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfstring>;
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<ResultOfstring> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfstring;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteFile(id: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/private/FilePrivate/DeleteFile/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDeleteFile(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    rateFile(body: RatingFileCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/private/FilePrivate/RateFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processRateFile(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFilePublicClient {
    /**
     * @return OK
     */
    downloadFile(fileName: string): Observable<FileStreamResult>;
    /**
     * @return OK
     */
    showFileFromUrl(fileName: string): Observable<FileStreamResult>;
    /**
     * @return OK
     */
    getAllFilesByCurriculumId(curriculumId: number): Observable<ResultOfListOfFileView>;
}

@Injectable({
    providedIn: 'root'
})
export class FilePublicClient implements IFilePublicClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    downloadFile(fileName: string, httpContext?: HttpContext): Observable<FileStreamResult> {
        let url_ = this.baseUrl + "/api/FilePublic/DownloadFile/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new globalThis.Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileStreamResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileStreamResult>;
        }));
    }

    protected processDownloadFile(response: HttpResponseBase): Observable<FileStreamResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as FileStreamResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    showFileFromUrl(fileName: string, httpContext?: HttpContext): Observable<FileStreamResult> {
        let url_ = this.baseUrl + "/api/FilePublic/ShowFileFromUrl/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new globalThis.Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowFileFromUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowFileFromUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileStreamResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileStreamResult>;
        }));
    }

    protected processShowFileFromUrl(response: HttpResponseBase): Observable<FileStreamResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as FileStreamResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllFilesByCurriculumId(curriculumId: number, httpContext?: HttpContext): Observable<ResultOfListOfFileView> {
        let url_ = this.baseUrl + "/api/FilePublic/GetAllFilesByCurriculumId/{curriculumId}";
        if (curriculumId === undefined || curriculumId === null)
            throw new globalThis.Error("The parameter 'curriculumId' must be defined.");
        url_ = url_.replace("{curriculumId}", encodeURIComponent("" + curriculumId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFilesByCurriculumId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFilesByCurriculumId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfFileView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfFileView>;
        }));
    }

    protected processGetAllFilesByCurriculumId(response: HttpResponseBase): Observable<ResultOfListOfFileView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfFileView;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IImageAdminClient {
    /**
     * @param id (optional) 
     * @param file (optional) 
     * @return OK
     */
    uploadCollegeImage(id?: number | undefined, file?: FileParameter | undefined): Observable<ResultOfboolean>;
    /**
     * @param id (optional) 
     * @param file (optional) 
     * @return OK
     */
    uploadUniversityImage(id?: number | undefined, file?: FileParameter | undefined): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    deleteImage(fileName: string): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ImageAdminClient implements IImageAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @param id (optional) 
     * @param file (optional) 
     * @return OK
     */
    uploadCollegeImage(id?: number | undefined, file?: FileParameter | undefined, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/ImageAdmin/UploadCollegeImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else
            content_.append("id", id.toString());
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadCollegeImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadCollegeImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUploadCollegeImage(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param file (optional) 
     * @return OK
     */
    uploadUniversityImage(id?: number | undefined, file?: FileParameter | undefined, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/ImageAdmin/UploadUniversityImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else
            content_.append("id", id.toString());
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadUniversityImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadUniversityImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUploadUniversityImage(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteImage(fileName: string, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/ImageAdmin/DeleteImage/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new globalThis.Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDeleteImage(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface INotificationsClient {
    /**
     * @return OK
     */
    markAllAsRead(body: MarkAllNotificationsAsReadCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    markAsRead(notificationId: number): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    userNotifications(userId: string): Observable<ResultOfListOfNotificationDto>;
    /**
     * @return OK
     */
    unreadCount(userId: string): Observable<ResultOfint>;
    /**
     * @return OK
     */
    delete(notificationId: number): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class NotificationsClient implements INotificationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    markAllAsRead(body: MarkAllNotificationsAsReadCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/Notifications/MarkAllAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processMarkAllAsRead(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    markAsRead(notificationId: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/Notifications/MarkAsRead/{notificationId}";
        if (notificationId === undefined || notificationId === null)
            throw new globalThis.Error("The parameter 'notificationId' must be defined.");
        url_ = url_.replace("{notificationId}", encodeURIComponent("" + notificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processMarkAsRead(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    userNotifications(userId: string, httpContext?: HttpContext): Observable<ResultOfListOfNotificationDto> {
        let url_ = this.baseUrl + "/api/Notifications/UserNotifications/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfNotificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfNotificationDto>;
        }));
    }

    protected processUserNotifications(response: HttpResponseBase): Observable<ResultOfListOfNotificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfNotificationDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    unreadCount(userId: string, httpContext?: HttpContext): Observable<ResultOfint> {
        let url_ = this.baseUrl + "/api/Notifications/UnreadCount/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnreadCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnreadCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfint>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfint>;
        }));
    }

    protected processUnreadCount(response: HttpResponseBase): Observable<ResultOfint> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfint;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    delete(notificationId: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/Notifications/Delete/{notificationId}";
        if (notificationId === undefined || notificationId === null)
            throw new globalThis.Error("The parameter 'notificationId' must be defined.");
        url_ = url_.replace("{notificationId}", encodeURIComponent("" + notificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOptionClient {
    /**
     * @return OK
     */
    addOption(body: AddOptionCommand): Observable<ResultOfOptionsDto>;
    /**
     * @return OK
     */
    updateOption(body: UpdateOptionCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    deleteOption(optionId: number): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class OptionClient implements IOptionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    addOption(body: AddOptionCommand, httpContext?: HttpContext): Observable<ResultOfOptionsDto> {
        let url_ = this.baseUrl + "/api/Option/AddOption";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOptionsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOptionsDto>;
        }));
    }

    protected processAddOption(response: HttpResponseBase): Observable<ResultOfOptionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfOptionsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateOption(body: UpdateOptionCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/Option/UpdateOption";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUpdateOption(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteOption(optionId: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/Option/DeleteOption/{optionId}";
        if (optionId === undefined || optionId === null)
            throw new globalThis.Error("The parameter 'optionId' must be defined.");
        url_ = url_.replace("{optionId}", encodeURIComponent("" + optionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDeleteOption(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPermissionAdminClient {
    /**
     * @return OK
     */
    addPermission(body: AddPermissionCommand): Observable<ResultOfPermissionDto>;
    /**
     * @return OK
     */
    updatePermission(body: UpdatePermissionCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    getAllPermissions(): Observable<ResultOfIEnumerableOfPermissionDto>;
    /**
     * @return OK
     */
    deletePermission(id: number): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class PermissionAdminClient implements IPermissionAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    addPermission(body: AddPermissionCommand, httpContext?: HttpContext): Observable<ResultOfPermissionDto> {
        let url_ = this.baseUrl + "/api/admin/PermissionAdmin/AddPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPermissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPermissionDto>;
        }));
    }

    protected processAddPermission(response: HttpResponseBase): Observable<ResultOfPermissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfPermissionDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updatePermission(body: UpdatePermissionCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/PermissionAdmin/UpdatePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUpdatePermission(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllPermissions(httpContext?: HttpContext): Observable<ResultOfIEnumerableOfPermissionDto> {
        let url_ = this.baseUrl + "/api/admin/PermissionAdmin/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfIEnumerableOfPermissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfIEnumerableOfPermissionDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ResultOfIEnumerableOfPermissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfIEnumerableOfPermissionDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deletePermission(id: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/PermissionAdmin/DeletePermission/{Id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDeletePermission(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuestionLeaderClient {
    /**
     * @return OK
     */
    exportTemplateForQuestions(questionsBankId: number): Observable<FileStreamResult>;
    /**
     * @return OK
     */
    addQuestion(body: AddQuestionCommand): Observable<ResultOfQuestionsDto>;
    /**
     * @return OK
     */
    addRingQuestions(questionsBankId: number, body: AddQuestionsDto[]): Observable<ResultOfboolean>;
    /**
     * @param file (optional) 
     * @param questionBankId (optional) 
     * @return OK
     */
    addByExcelQuestions(file?: FileParameter | undefined, questionBankId?: number | undefined): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    updateQuestion(body: UpdateQuestionCommand): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class QuestionLeaderClient implements IQuestionLeaderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    exportTemplateForQuestions(questionsBankId: number, httpContext?: HttpContext): Observable<FileStreamResult> {
        let url_ = this.baseUrl + "/api/leader/QuestionLeader/ExportTemplateForQuestions/{questionsBankId}";
        if (questionsBankId === undefined || questionsBankId === null)
            throw new globalThis.Error("The parameter 'questionsBankId' must be defined.");
        url_ = url_.replace("{questionsBankId}", encodeURIComponent("" + questionsBankId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTemplateForQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTemplateForQuestions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileStreamResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileStreamResult>;
        }));
    }

    protected processExportTemplateForQuestions(response: HttpResponseBase): Observable<FileStreamResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as FileStreamResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    addQuestion(body: AddQuestionCommand, httpContext?: HttpContext): Observable<ResultOfQuestionsDto> {
        let url_ = this.baseUrl + "/api/leader/QuestionLeader/AddQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfQuestionsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfQuestionsDto>;
        }));
    }

    protected processAddQuestion(response: HttpResponseBase): Observable<ResultOfQuestionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfQuestionsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    addRingQuestions(questionsBankId: number, body: AddQuestionsDto[], httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/leader/QuestionLeader/AddRingQuestions/{questionsBankId}";
        if (questionsBankId === undefined || questionsBankId === null)
            throw new globalThis.Error("The parameter 'questionsBankId' must be defined.");
        url_ = url_.replace("{questionsBankId}", encodeURIComponent("" + questionsBankId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRingQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRingQuestions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processAddRingQuestions(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param file (optional) 
     * @param questionBankId (optional) 
     * @return OK
     */
    addByExcelQuestions(file?: FileParameter | undefined, questionBankId?: number | undefined, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/leader/QuestionLeader/AddByExcelQuestions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (questionBankId === null || questionBankId === undefined)
            throw new globalThis.Error("The parameter 'questionBankId' cannot be null.");
        else
            content_.append("QuestionBankId", questionBankId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddByExcelQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddByExcelQuestions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processAddByExcelQuestions(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateQuestion(body: UpdateQuestionCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/leader/QuestionLeader/UpdateQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUpdateQuestion(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ILeaderClient {
    /**
     * @return OK
     */
    questionLeader(questionId: number): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class LeaderClient implements ILeaderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    questionLeader(questionId: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/leader/QuestionLeader/{questionId}";
        if (questionId === undefined || questionId === null)
            throw new globalThis.Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuestionLeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuestionLeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processQuestionLeader(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuestionPublicClient {
    /**
     * @return OK
     */
    byBank(questionsBankId: number): Observable<ResultOfListOfQuestionsDto>;
}

@Injectable({
    providedIn: 'root'
})
export class QuestionPublicClient implements IQuestionPublicClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    byBank(questionsBankId: number, httpContext?: HttpContext): Observable<ResultOfListOfQuestionsDto> {
        let url_ = this.baseUrl + "/api/QuestionPublic/ByBank/{questionsBankId}";
        if (questionsBankId === undefined || questionsBankId === null)
            throw new globalThis.Error("The parameter 'questionsBankId' must be defined.");
        url_ = url_.replace("{questionsBankId}", encodeURIComponent("" + questionsBankId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processByBank(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processByBank(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfQuestionsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfQuestionsDto>;
        }));
    }

    protected processByBank(response: HttpResponseBase): Observable<ResultOfListOfQuestionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfQuestionsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICountClient {
    /**
     * @return OK
     */
    byBank(questionsBankId: number): Observable<ResultOfint>;
}

@Injectable({
    providedIn: 'root'
})
export class CountClient implements ICountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    byBank(questionsBankId: number, httpContext?: HttpContext): Observable<ResultOfint> {
        let url_ = this.baseUrl + "/api/QuestionPublic/Count/ByBank/{questionsBankId}";
        if (questionsBankId === undefined || questionsBankId === null)
            throw new globalThis.Error("The parameter 'questionsBankId' must be defined.");
        url_ = url_.replace("{questionsBankId}", encodeURIComponent("" + questionsBankId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processByBank(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processByBank(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfint>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfint>;
        }));
    }

    protected processByBank(response: HttpResponseBase): Observable<ResultOfint> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfint;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IApiClient {
    /**
     * @return OK
     */
    questionPublic(questionId: number): Observable<ResultOfQuestionsDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ApiClient implements IApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    questionPublic(questionId: number, httpContext?: HttpContext): Observable<ResultOfQuestionsDto> {
        let url_ = this.baseUrl + "/api/QuestionPublic/{questionId}";
        if (questionId === undefined || questionId === null)
            throw new globalThis.Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuestionPublic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuestionPublic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfQuestionsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfQuestionsDto>;
        }));
    }

    protected processQuestionPublic(response: HttpResponseBase): Observable<ResultOfQuestionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfQuestionsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuestionsBankLeaderClient {
    /**
     * @return OK
     */
    createQuestion(body: AddQuestionsBankCommand): Observable<ResultOfQuestionsBankDto>;
    /**
     * @return OK
     */
    updateQuestion(body: UpdateQuestionsBankCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    deleteQuestion(id: number): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class QuestionsBankLeaderClient implements IQuestionsBankLeaderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    createQuestion(body: AddQuestionsBankCommand, httpContext?: HttpContext): Observable<ResultOfQuestionsBankDto> {
        let url_ = this.baseUrl + "/api/leader/QuestionsBankLeader/CreateQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfQuestionsBankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfQuestionsBankDto>;
        }));
    }

    protected processCreateQuestion(response: HttpResponseBase): Observable<ResultOfQuestionsBankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfQuestionsBankDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateQuestion(body: UpdateQuestionsBankCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/leader/QuestionsBankLeader/UpdateQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUpdateQuestion(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteQuestion(id: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/leader/QuestionsBankLeader/DeleteQuestion/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDeleteQuestion(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuestionsBankPublicClient {
    /**
     * @return OK
     */
    questionsBanks(curriculumId: number): Observable<ResultOfListOfQuestionsBankDto>;
    /**
     * @return OK
     */
    questionsBankById(id: number): Observable<ResultOfQuestionsBankDto>;
}

@Injectable({
    providedIn: 'root'
})
export class QuestionsBankPublicClient implements IQuestionsBankPublicClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    questionsBanks(curriculumId: number, httpContext?: HttpContext): Observable<ResultOfListOfQuestionsBankDto> {
        let url_ = this.baseUrl + "/api/QuestionsBankPublic/QuestionsBanks/{curriculumId}";
        if (curriculumId === undefined || curriculumId === null)
            throw new globalThis.Error("The parameter 'curriculumId' must be defined.");
        url_ = url_.replace("{curriculumId}", encodeURIComponent("" + curriculumId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuestionsBanks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuestionsBanks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfQuestionsBankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfQuestionsBankDto>;
        }));
    }

    protected processQuestionsBanks(response: HttpResponseBase): Observable<ResultOfListOfQuestionsBankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfQuestionsBankDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    questionsBankById(id: number, httpContext?: HttpContext): Observable<ResultOfQuestionsBankDto> {
        let url_ = this.baseUrl + "/api/QuestionsBankPublic/QuestionsBankById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuestionsBankById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuestionsBankById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfQuestionsBankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfQuestionsBankDto>;
        }));
    }

    protected processQuestionsBankById(response: HttpResponseBase): Observable<ResultOfQuestionsBankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfQuestionsBankDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRoleAdminClient {
    /**
     * @return OK
     */
    createRole(body: AddRoleCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    getAllRoles(): Observable<ResultOfListOfRoleDto>;
    /**
     * @return OK
     */
    updateRole(body: UpdateRoleCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    deleteRole(body: DeleteRoleCommand): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class RoleAdminClient implements IRoleAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    createRole(body: AddRoleCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/RoleAdmin/CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllRoles(httpContext?: HttpContext): Observable<ResultOfListOfRoleDto> {
        let url_ = this.baseUrl + "/api/admin/RoleAdmin/GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfRoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfRoleDto>;
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<ResultOfListOfRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfRoleDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateRole(body: UpdateRoleCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/RoleAdmin/UpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteRole(body: DeleteRoleCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/RoleAdmin/DeleteRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRolePermissionAdminClient {
    /**
     * @return OK
     */
    addRolePermission(body: AddRolePermissionCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    removeRolePermission(body: DeleteRolePermissionCommand): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class RolePermissionAdminClient implements IRolePermissionAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    addRolePermission(body: AddRolePermissionCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/RolePermissionAdmin/AddRolePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processAddRolePermission(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    removeRolePermission(body: DeleteRolePermissionCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/RolePermissionAdmin/RemoveRolePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRolePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processRemoveRolePermission(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRolePermissionPublicClient {
    /**
     * @return OK
     */
    getPermissionsByRoleName(roleName: string): Observable<ResultOfListOfGetPermissionsDto>;
}

@Injectable({
    providedIn: 'root'
})
export class RolePermissionPublicClient implements IRolePermissionPublicClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    getPermissionsByRoleName(roleName: string, httpContext?: HttpContext): Observable<ResultOfListOfGetPermissionsDto> {
        let url_ = this.baseUrl + "/api/RolePermissionPublic/GetPermissionsByRoleName/{roleName}";
        if (roleName === undefined || roleName === null)
            throw new globalThis.Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionsByRoleName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsByRoleName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfGetPermissionsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfGetPermissionsDto>;
        }));
    }

    protected processGetPermissionsByRoleName(response: HttpResponseBase): Observable<ResultOfListOfGetPermissionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfGetPermissionsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRolePublicClient {
    /**
     * @return OK
     */
    getUserRoles(userId: string): Observable<ResultOfIEnumerableOfstring>;
}

@Injectable({
    providedIn: 'root'
})
export class RolePublicClient implements IRolePublicClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    getUserRoles(userId: string, httpContext?: HttpContext): Observable<ResultOfIEnumerableOfstring> {
        let url_ = this.baseUrl + "/api/RolePublic/GetUserRoles/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfIEnumerableOfstring>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfIEnumerableOfstring>;
        }));
    }

    protected processGetUserRoles(response: HttpResponseBase): Observable<ResultOfIEnumerableOfstring> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfIEnumerableOfstring;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISettingsClient {
    /**
     * @return OK
     */
    getAllSettings(): Observable<ResultOfListOfSettingsDto>;
    /**
     * @return OK
     */
    updateSettings(body: UpdateSettingsCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    createSetting(body: AddSettingsCommand): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class SettingsClient implements ISettingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    getAllSettings(httpContext?: HttpContext): Observable<ResultOfListOfSettingsDto> {
        let url_ = this.baseUrl + "/api/Settings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfSettingsDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<ResultOfListOfSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfSettingsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateSettings(body: UpdateSettingsCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/Settings/UpdateSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUpdateSettings(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createSetting(body: AddSettingsCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/Settings/CreateSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processCreateSetting(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISubjectAdminClient {
    /**
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    getAllSubjects(pageSize?: number | undefined, pageNumber?: number | undefined): Observable<ResultOfListOfGetSubjectDto>;
    /**
     * @return OK
     */
    addSubject(body: AddSubjectCommand): Observable<ResultOfSubjectDto>;
    /**
     * @return OK
     */
    updateSubject(body: UpdateSubjectCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    deleteSubject(id: number): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class SubjectAdminClient implements ISubjectAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return OK
     */
    getAllSubjects(pageSize?: number | undefined, pageNumber?: number | undefined, httpContext?: HttpContext): Observable<ResultOfListOfGetSubjectDto> {
        let url_ = this.baseUrl + "/api/admin/SubjectAdmin/GetAllSubjects?";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfGetSubjectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfGetSubjectDto>;
        }));
    }

    protected processGetAllSubjects(response: HttpResponseBase): Observable<ResultOfListOfGetSubjectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfGetSubjectDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    addSubject(body: AddSubjectCommand, httpContext?: HttpContext): Observable<ResultOfSubjectDto> {
        let url_ = this.baseUrl + "/api/admin/SubjectAdmin/AddSubject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSubject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSubject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfSubjectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfSubjectDto>;
        }));
    }

    protected processAddSubject(response: HttpResponseBase): Observable<ResultOfSubjectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfSubjectDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateSubject(body: UpdateSubjectCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/SubjectAdmin/UpdateSubject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUpdateSubject(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteSubject(id: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/SubjectAdmin/DeleteSubject/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDeleteSubject(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISubjectPublicClient {
    /**
     * @return OK
     */
    getAllSubjects(departmentId: number): Observable<ResultOfListOfGetSubjectDto>;
    /**
     * @return OK
     */
    getSubjectById(id: number): Observable<ResultOfGetSubjectDto>;
}

@Injectable({
    providedIn: 'root'
})
export class SubjectPublicClient implements ISubjectPublicClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    getAllSubjects(departmentId: number, httpContext?: HttpContext): Observable<ResultOfListOfGetSubjectDto> {
        let url_ = this.baseUrl + "/api/SubjectPublic/GetAllSubjects/{departmentId}";
        if (departmentId === undefined || departmentId === null)
            throw new globalThis.Error("The parameter 'departmentId' must be defined.");
        url_ = url_.replace("{departmentId}", encodeURIComponent("" + departmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfGetSubjectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfGetSubjectDto>;
        }));
    }

    protected processGetAllSubjects(response: HttpResponseBase): Observable<ResultOfListOfGetSubjectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfGetSubjectDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getSubjectById(id: number, httpContext?: HttpContext): Observable<ResultOfGetSubjectDto> {
        let url_ = this.baseUrl + "/api/SubjectPublic/GetSubjectById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubjectById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubjectById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetSubjectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetSubjectDto>;
        }));
    }

    protected processGetSubjectById(response: HttpResponseBase): Observable<ResultOfGetSubjectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfGetSubjectDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITestClient {
    /**
     * @return OK
     */
    start(body: StartTestCommand): Observable<ResultOfListOfQuestionWithOptions>;
}

@Injectable({
    providedIn: 'root'
})
export class TestClient implements ITestClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    start(body: StartTestCommand, httpContext?: HttpContext): Observable<ResultOfListOfQuestionWithOptions> {
        let url_ = this.baseUrl + "/api/Test/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfQuestionWithOptions>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfQuestionWithOptions>;
        }));
    }

    protected processStart(response: HttpResponseBase): Observable<ResultOfListOfQuestionWithOptions> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfQuestionWithOptions;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUniversityAdminClient {
    /**
     * @return OK
     */
    addUniversity(body: AddUniversityCommand): Observable<ResultOfUniversityDto>;
    /**
     * @return OK
     */
    updateUniversity(body: UpdateUniversityCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    deleteUniversity(id: number): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class UniversityAdminClient implements IUniversityAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    addUniversity(body: AddUniversityCommand, httpContext?: HttpContext): Observable<ResultOfUniversityDto> {
        let url_ = this.baseUrl + "/api/admin/UniversityAdmin/AddUniversity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUniversity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUniversity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUniversityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUniversityDto>;
        }));
    }

    protected processAddUniversity(response: HttpResponseBase): Observable<ResultOfUniversityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfUniversityDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateUniversity(body: UpdateUniversityCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/UniversityAdmin/UpdateUniversity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUniversity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUniversity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUpdateUniversity(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteUniversity(id: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/UniversityAdmin/DeleteUniversity/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUniversity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUniversity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDeleteUniversity(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUniversityPublicClient {
    /**
     * @return OK
     */
    getUniversit(): Observable<ResultOfUniversityDetialsDto>;
}

@Injectable({
    providedIn: 'root'
})
export class UniversityPublicClient implements IUniversityPublicClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    getUniversit(httpContext?: HttpContext): Observable<ResultOfUniversityDetialsDto> {
        let url_ = this.baseUrl + "/api/UniversityPublic/GetUniversit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUniversit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUniversit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUniversityDetialsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUniversityDetialsDto>;
        }));
    }

    protected processGetUniversit(response: HttpResponseBase): Observable<ResultOfUniversityDetialsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfUniversityDetialsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserPermissionAdminClient {
    /**
     * @return OK
     */
    addUserPermission(body: AddUserPermissionCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    removeUserPermission(body: DeleteUserPermissionCommand): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class UserPermissionAdminClient implements IUserPermissionAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    addUserPermission(body: AddUserPermissionCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/UserPermissionAdmin/AddUserPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processAddUserPermission(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    removeUserPermission(body: DeleteUserPermissionCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/UserPermissionAdmin/RemoveUserPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processRemoveUserPermission(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserPermissionPublicClient {
    /**
     * @return OK
     */
    getPermissionsByUserId(userId: string): Observable<ResultOfIEnumerableOfGetPermissionsDto>;
}

@Injectable({
    providedIn: 'root'
})
export class UserPermissionPublicClient implements IUserPermissionPublicClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    getPermissionsByUserId(userId: string, httpContext?: HttpContext): Observable<ResultOfIEnumerableOfGetPermissionsDto> {
        let url_ = this.baseUrl + "/api/UserPermissionPublic/GetPermissionsByUserId/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionsByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfIEnumerableOfGetPermissionsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfIEnumerableOfGetPermissionsDto>;
        }));
    }

    protected processGetPermissionsByUserId(response: HttpResponseBase): Observable<ResultOfIEnumerableOfGetPermissionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfIEnumerableOfGetPermissionsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IYearAdminClient {
    /**
     * @return OK
     */
    addYear(body: AddYearCommand): Observable<ResultOfYearDto>;
    /**
     * @return OK
     */
    updateYear(body: UpdateYearCommand): Observable<ResultOfboolean>;
    /**
     * @return OK
     */
    deleteYear(yearId: number): Observable<ResultOfboolean>;
}

@Injectable({
    providedIn: 'root'
})
export class YearAdminClient implements IYearAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    addYear(body: AddYearCommand, httpContext?: HttpContext): Observable<ResultOfYearDto> {
        let url_ = this.baseUrl + "/api/admin/YearAdmin/AddYear";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfYearDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfYearDto>;
        }));
    }

    protected processAddYear(response: HttpResponseBase): Observable<ResultOfYearDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfYearDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateYear(body: UpdateYearCommand, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/YearAdmin/UpdateYear";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processUpdateYear(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteYear(yearId: number, httpContext?: HttpContext): Observable<ResultOfboolean> {
        let url_ = this.baseUrl + "/api/admin/YearAdmin/DeleteYear/{yearId}";
        if (yearId === undefined || yearId === null)
            throw new globalThis.Error("The parameter 'yearId' must be defined.");
        url_ = url_.replace("{yearId}", encodeURIComponent("" + yearId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfboolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfboolean>;
        }));
    }

    protected processDeleteYear(response: HttpResponseBase): Observable<ResultOfboolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfboolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IYearPublicClient {
    /**
     * @return OK
     */
    getAllYears(collegeId: number): Observable<ResultOfListOfGetYearDto>;
    /**
     * @return OK
     */
    getYearById(yearId: number): Observable<ResultOfGetYearDto>;
}

@Injectable({
    providedIn: 'root'
})
export class YearPublicClient implements IYearPublicClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://elm.runasp.net/";
    }

    /**
     * @return OK
     */
    getAllYears(collegeId: number, httpContext?: HttpContext): Observable<ResultOfListOfGetYearDto> {
        let url_ = this.baseUrl + "/api/YearPublic/GetAllYears/{collegeId}";
        if (collegeId === undefined || collegeId === null)
            throw new globalThis.Error("The parameter 'collegeId' must be defined.");
        url_ = url_.replace("{collegeId}", encodeURIComponent("" + collegeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllYears(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllYears(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfGetYearDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfGetYearDto>;
        }));
    }

    protected processGetAllYears(response: HttpResponseBase): Observable<ResultOfListOfGetYearDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfListOfGetYearDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getYearById(yearId: number, httpContext?: HttpContext): Observable<ResultOfGetYearDto> {
        let url_ = this.baseUrl + "/api/YearPublic/GetYearById/{yearId}";
        if (yearId === undefined || yearId === null)
            throw new globalThis.Error("The parameter 'yearId' must be defined.");
        url_ = url_.replace("{yearId}", encodeURIComponent("" + yearId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetYearById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetYearById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetYearDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetYearDto>;
        }));
    }

    protected processGetYearById(response: HttpResponseBase): Observable<ResultOfGetYearDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver) as ResultOfGetYearDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface AddCollegeCommand {
    name: string;
    universityId: number;

    [key: string]: any;
}

export interface AddCurriculumCommand {
    subjectId: number;
    yearId: number;
    departmentId: number;
    startMonth: number;
    endMonth: number;
    doctorId: number;

    [key: string]: any;
}

export interface AddDepartmentCommand {
    name: string;
    isPaid: boolean;
    type: number;
    collegeId: number;

    [key: string]: any;
}

export interface AddOptionCommand {
    content: string;
    isCorrect: boolean;
    questionId: number;

    [key: string]: any;
}

export interface AddOptionsDto {
    content?: string;
    isCorrect?: boolean;

    [key: string]: any;
}

export interface AddPermissionCommand {
    name: string;

    [key: string]: any;
}

export interface AddQuestionCommand {
    questionBankId: number;
    questionsDto: AddQuestionsDto;

    [key: string]: any;
}

export interface AddQuestionsBankCommand {
    name: string;
    curriculumId: number;

    [key: string]: any;
}

export interface AddQuestionsDto {
    content?: string;
    questionType?: string;
    options?: AddOptionsDto[];

    [key: string]: any;
}

export interface AddRoleCommand {
    roleName: string;

    [key: string]: any;
}

export interface AddRolePermissionCommand {
    roleName: string;
    permissionName: string;

    [key: string]: any;
}

export interface AddSettingsCommand {
    key: string;
    value: string;

    [key: string]: any;
}

export interface AddSubjectCommand {
    name: string;
    code: string;

    [key: string]: any;
}

export interface AddUniversityCommand {
    name: string;

    [key: string]: any;
}

export interface AddUserPermissionCommand {
    userName: string;
    permissionName: string;

    [key: string]: any;
}

export interface AddYearCommand {
    name: string;
    collegeId: number;

    [key: string]: any;
}

export interface AdminCurriculumDto {
    id?: number;
    subjectName?: string;
    departmentName?: string;
    yearName?: string;
    doctorName?: string;

    [key: string]: any;
}

export interface AuthModelDto {
    userName?: string;
    roles?: string[];
    fullName?: string;
    userId?: string;
    token?: string;
    isAuthenticated?: boolean;
    expiresOn?: Date;
    refreshTokenExpiration?: Date;

    [key: string]: any;
}

export interface ChangePasswordCommand {
    userId: string;
    currentPassword: string;
    newPassword: string;
    confidentialPassword: string;

    [key: string]: any;
}

export interface CollegeDto {
    id?: number;
    name?: string;

    [key: string]: any;
}

export interface CurriculumDto {
    id?: number;
    subjectId?: number;
    yearId?: number;
    departmentId?: number;
    doctorId?: number;

    [key: string]: any;
}

export interface DeleteCommand {
    userId: string;

    [key: string]: any;
}

export interface DeleteRoleCommand {
    name: string;

    [key: string]: any;
}

export interface DeleteRolePermissionCommand {
    roleName: string;
    permissionName: string;

    [key: string]: any;
}

export interface DeleteUserPermissionCommand {
    userName: string;
    permissionName: string;

    [key: string]: any;
}

export interface DepartmentDto {
    id?: number;
    name?: string;
    isPaid?: boolean;
    type?: string;
    collegeId?: number;

    [key: string]: any;
}

export interface DepartmentDto2 {
    id?: number;
    name?: string;
    isPaid?: boolean;
    type?: string;
    collegeId?: number;

    [key: string]: any;
}

export interface DoctorDto {
    userId?: string;
    userName?: string;
    fullName?: string;
    title?: string;
    doctorId?: number;
    isActived?: boolean;

    [key: string]: any;
}

export interface EntityTagHeaderValue {
    tag?: StringSegment;
    isWeak?: boolean;

    [key: string]: any;
}

export interface FileStreamResult {
    fileStream?: string;
    contentType?: string | null;
    fileDownloadName?: string | null;
    lastModified?: Date | null;
    entityTag?: EntityTagHeaderValue | null;
    enableRangeProcessing?: boolean;

    [key: string]: any;
}

export interface FileView {
    id?: number;
    name?: string;
    storageName?: string;
    doctorRatedName?: string;
    comment?: string | null;
    ratedAt?: Date | null;

    [key: string]: any;
}

export interface GetCollegeDto {
    id?: number;
    name?: string;
    storageName?: string;
    url?: string;

    [key: string]: any;
}

export interface GetCurriculumDto {
    id?: number;
    subjectName?: string;

    [key: string]: any;
}

export interface GetCurriculumDto2 {
    id?: number;
    subjectName?: string;

    [key: string]: any;
}

export interface GetDepartmentDto {
    id?: number;
    name?: string;
    isPaid?: boolean;
    type?: string;

    [key: string]: any;
}

export interface GetDepartmentDto2 {
    id?: number;
    name?: string;
    isPaid?: boolean;
    type?: string;

    [key: string]: any;
}

export interface GetPermissionsDto {
    permissionId?: number;
    permissionName?: string;

    [key: string]: any;
}

export interface GetSubjectDto {
    id?: number;
    name?: string;
    code?: string;

    [key: string]: any;
}

export interface GetSubjectDto2 {
    id?: number;
    name?: string;
    code?: string;

    [key: string]: any;
}

export interface GetYearDto {
    id?: number;
    name?: string;

    [key: string]: any;
}

export interface GetYearDto2 {
    id?: number;
    name?: string;

    [key: string]: any;
}

export interface LeaderDto {
    userId?: string;
    userName?: string;
    fullName?: string;
    yearName?: string;
    departmentName?: string;
    isActived?: boolean;

    [key: string]: any;
}

export interface LoginCommand {
    userName: string;
    password: string;

    [key: string]: any;
}

export interface MarkAllNotificationsAsReadCommand {
    userId: string;

    [key: string]: any;
}

export interface NotificationDto {
    id?: number;
    title?: string;
    message?: string;
    isRead?: boolean;
    createdAt?: Date;

    [key: string]: any;
}

export interface OptionData {
    id: number;
    content: string;
    isCorrect: boolean;

    [key: string]: any;
}

export interface OptionsDto {
    id?: number;
    content?: string;
    isCorrect?: boolean;

    [key: string]: any;
}

export interface OptionsDto2 {
    id?: number;
    content?: string;
    isCorrect?: boolean;

    [key: string]: any;
}

export interface PermissionDto {
    id?: number;
    name?: string;

    [key: string]: any;
}

export interface PermissionDto2 {
    id?: number;
    name?: string;

    [key: string]: any;
}

export interface QuestionsBankDto {
    id?: number;
    name?: string;

    [key: string]: any;
}

export interface QuestionsBankDto2 {
    id?: number;
    name?: string;

    [key: string]: any;
}

export interface QuestionsDto {
    id?: number;
    content?: string;
    questionType?: string;
    options?: OptionsDto2[];

    [key: string]: any;
}

export interface QuestionsDto2 {
    id?: number;
    content?: string;
    questionType?: string;
    options?: OptionsDto2[];

    [key: string]: any;
}

export interface QuestionWithOptions {
    id: number;
    content: string;
    questionType: string;
    options: OptionData[];

    [key: string]: any;
}

export interface RatingFileCommand {
    fileId: number;
    userId: string;
    comment: string;
    rating: number;

    [key: string]: any;
}

export interface RegisterDoctorCommand {
    userName: string;
    password: string;
    confirmPassword: string;
    fullName: string;
    title: string;

    [key: string]: any;
}

export interface RegisterLeaderCommand {
    userName: string;
    password: string;
    confirmPassword: string;
    fullName: string;
    departmentId: number;
    yearId: number;

    [key: string]: any;
}

export interface ResultOfAuthModelDto {
    data?: AuthModelDto | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfboolean {
    data?: boolean;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfCollegeDto {
    data?: CollegeDto | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfCurriculumDto {
    data?: CurriculumDto | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfDepartmentDto {
    data?: DepartmentDto | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfGetCurriculumDto {
    data?: GetCurriculumDto2 | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfGetDepartmentDto {
    data?: GetDepartmentDto2 | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfGetSubjectDto {
    data?: GetSubjectDto2 | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfGetYearDto {
    data?: GetYearDto2 | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfIEnumerableOfDoctorDto {
    data?: DoctorDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfIEnumerableOfGetPermissionsDto {
    data?: GetPermissionsDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfIEnumerableOfLeaderDto {
    data?: LeaderDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfIEnumerableOfPermissionDto {
    data?: PermissionDto2[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfIEnumerableOfstring {
    data?: string[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfint {
    data?: number;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfAdminCurriculumDto {
    data?: AdminCurriculumDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfDepartmentDto {
    data?: DepartmentDto2[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfFileView {
    data?: FileView[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfGetCollegeDto {
    data?: GetCollegeDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfGetCurriculumDto {
    data?: GetCurriculumDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfGetDepartmentDto {
    data?: GetDepartmentDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfGetPermissionsDto {
    data?: GetPermissionsDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfGetSubjectDto {
    data?: GetSubjectDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfGetYearDto {
    data?: GetYearDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfNotificationDto {
    data?: NotificationDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfQuestionsBankDto {
    data?: QuestionsBankDto2[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfQuestionsDto {
    data?: QuestionsDto2[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfQuestionWithOptions {
    data?: QuestionWithOptions[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfRoleDto {
    data?: RoleDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfListOfSettingsDto {
    data?: SettingsDto[] | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfOptionsDto {
    data?: OptionsDto | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfPermissionDto {
    data?: PermissionDto | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfQuestionsBankDto {
    data?: QuestionsBankDto | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfQuestionsDto {
    data?: QuestionsDto | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfstring {
    data?: string | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfSubjectDto {
    data?: SubjectDto | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfUniversityDetialsDto {
    data?: UniversityDetialsDto | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfUniversityDto {
    data?: UniversityDto | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface ResultOfYearDto {
    data?: YearDto | null;
    isSuccess?: boolean;
    statusCode?: number;
    errors?: ValidationError[];
    message?: string | null;

    [key: string]: any;
}

export interface RevokeTokenCommand {
    token: string;

    [key: string]: any;
}

export interface RoleDto {
    name?: string;

    [key: string]: any;
}

export interface SettingsDto {
    key: string;
    value: string;

    [key: string]: any;
}

export interface StartTestCommand {
    questionsBankId: number;
    numberOfQuestions: number;

    [key: string]: any;
}

export interface StringSegment {
    buffer?: string | null;
    offset?: number;
    length?: number;
    value?: string | null;
    hasValue?: boolean;

    [key: string]: any;
}

export interface SubjectDto {
    id?: string;
    name?: string;
    code?: string;

    [key: string]: any;
}

export interface UniversityDetialsDto {
    id?: number;
    name?: string;
    storageName?: string;
    url?: string;

    [key: string]: any;
}

export interface UniversityDto {
    id?: number;
    name?: string;

    [key: string]: any;
}

export interface UpdateCollegeCommand {
    id: number;
    name: string;

    [key: string]: any;
}

export interface UpdateCurriculumCommand {
    id: number;
    subjectId: number;
    yearId: number;
    departmentId: number;
    doctorId: number;

    [key: string]: any;
}

export interface UpdateDateCurriculumCommand {
    id: number;
    startMonth: number;
    endMonth: number;

    [key: string]: any;
}

export interface UpdateDepartmentCommand {
    id: number;
    name: string;
    isPaid: boolean;
    type: number;

    [key: string]: any;
}

export interface UpdateOptionCommand {
    optionId: number;
    content: string;
    isCorrect: boolean;

    [key: string]: any;
}

export interface UpdatePermissionCommand {
    id: number;
    name: string;

    [key: string]: any;
}

export interface UpdateQuestionCommand {
    id: number;
    content: string;
    questionType: string;

    [key: string]: any;
}

export interface UpdateQuestionsBankCommand {
    id: number;
    name: string;
    curriculumId: number;

    [key: string]: any;
}

export interface UpdateRoleCommand {
    oldName: string;
    newName: string;

    [key: string]: any;
}

export interface UpdateSettingsCommand {
    key: string;
    value: string;

    [key: string]: any;
}

export interface UpdateSubjectCommand {
    id: number;
    name: string;
    code: string;

    [key: string]: any;
}

export interface UpdateUniversityCommand {
    id: number;
    name: string;

    [key: string]: any;
}

export interface UpdateYearCommand {
    id: number;
    name: string;

    [key: string]: any;
}

export interface ValidationError {
    propertyName?: string;
    errorMessage?: string;
    errorCode?: string;
    attemptedValue?: any;
    severity?: number;

    [key: string]: any;
}

export interface YearDto {
    id?: number;
    name?: string;
    collegeId?: number;

    [key: string]: any;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}